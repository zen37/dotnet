# Database Patterns

## BaseEntity Pattern

### Overview
The `BaseEntity` class provides a consistent way to define a primary key (`Id`) across all entities in a .NET application. This promotes reusability, maintainability, and uniformity across your data models.

---

### Why Use BaseEntity?
- **Consistency**: Ensures all entities have a uniform structure for primary keys.
- **Reusability**: Centralizes common functionality, such as the primary key definition or shared methods.
- **ORM Friendliness**: Simplifies mapping and querying by enforcing standard conventions.
- **Maintainability**: Changes to `Id` or shared logic apply to all entities inheriting from `BaseEntity`.

---

### Example Implementation
```csharp
public abstract class BaseEntity
{
    protected BaseEntity(int id)
    {
        this.Id = id;
    }

    protected BaseEntity()
    {
        this.Id = 0;
    }

    [Column("id")]
    public int Id { get; set; }
}
```

#### Key Points:
1. **Encapsulation with Constructors**:
   - Parameterized constructor allows creating an entity with a specific `Id`, useful for testing or specific scenarios.
   - Parameterless constructor sets a default value of `0` for `Id`, which is typical when using auto-generated primary keys.

2. **Column Mapping**:
   - The `[Column("id")]` attribute ensures proper mapping to the database column, explicitly specifying the name if conventions differ.

3. **Centralized Key Definition**:
   - Defining `Id` in `BaseEntity` ensures all derived entities automatically inherit it, promoting consistency.

4. **Flexibility**:
   - If `Id` behavior changes (e.g., switching to `Guid` or adding validation), modifying `BaseEntity` applies to all derived classes.

---

### Example Usage in a Derived Class
```csharp
[Table("user_roles")]
public class UserRole : BaseEntity
{
    public UserRole() : base() // Calls parameterless BaseEntity constructor
    {
        Users = new List<User>();
    }

    public UserRole(int id, string roleName) : base(id) // Calls parameterized BaseEntity constructor
    {
        RoleName = roleName;
        Users = new List<User>();
    }

    [Column("user_role_name")]
    public string RoleName { get; set; }

    public virtual IList<User> Users { get; set; }
}
```

---

### Real-World Usage Example
```csharp
// Creating a new UserRole
var adminRole = new UserRole(1, "Admin");
context.UserRoles.Add(adminRole);
context.SaveChanges();

// Querying UserRoles
var roles = context.UserRoles.ToList();
foreach (var role in roles)
{
    Console.WriteLine($"Role: {role.RoleName}, Id: {role.Id}");
}
```

---

### Common Pitfalls and Solutions
1. **Not Initializing Collections**:
   - **Problem**: Accessing a collection property like `Users` before initializing it can result in a `NullReferenceException`.
   - **Solution**: Initialize collections in the constructor or directly in the property definition.
     ```csharp
     public virtual IList<User> Users { get; set; } = new List<User>();
     ```

2. **Overriding `Id` in Derived Classes**:
   - **Problem**: Redefining `Id` in a derived class can cause conflicts or unexpected behavior in ORM mappings.
   - **Solution**: Avoid overriding `Id` in derived classes unless absolutely necessary.

---

### ORM-Specific Notes
- **Entity Framework Core**:
  - Ensure that `BaseEntity` has a parameterless constructor for EF Core to materialize objects.
  - Use `[Key]` and `[DatabaseGenerated(DatabaseGeneratedOption.Identity)]` to control `Id` generation.

- **NHibernate**:
  - Add XML mappings or Fluent mappings for `BaseEntity` if annotations are insufficient for your schema.

---

### Advantages of This Pattern
1. **Consistency Across Entities**:
   - All entities share a common primary key structure, reducing the risk of inconsistencies.

2. **Ease of Maintenance**:
   - Changes to `Id` implementation only need to be made in `BaseEntity`.

3. **ORM Compatibility**:
   - Attributes like `[Column("id")]` ensure proper mapping and alignment with database schemas.

4. **Simplified Derived Classes**:
   - Derived entities can focus on their specific properties and relationships without worrying about primary key implementation.

---

### Possible Enhancements
1. **Immutability for Auto-Generated Keys**:
   - If `Id` is auto-generated by the database, consider making it read-only:
     ```csharp
     [Key]
     [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
     [Column("id")]
     public int Id { get; private set; }
     ```

2. **Default `Id` Handling**:
   - Consider removing default initialization of `Id` if the ORM assigns values automatically.

---

### Future Topics
- Patterns for composite keys.
- Implementing a `Guid`-based `BaseEntity`.
- Best practices for handling soft deletes and audit fields (`CreatedAt`, `UpdatedAt`) in the base class.
